---
sidebar_position: 2
title: "Data Structures"
---

import Tooltip from '@site/src/components/Tooltip';
import { tooltipDefinitions } from '@site/src/constants/tooltipDefinitions';

# Data Structures

## Channel

Represents the configuration of a <Tooltip content={tooltipDefinitions.channel}>state channel</Tooltip>.

```solidity
struct Channel {
    address[] participants;  // List of participants in the channel
    address adjudicator;     // Contract that validates state transitions
    uint64 challenge;        // Duration in seconds for dispute resolution
    uint64 nonce;           // Unique identifier for the channel
}
```

**Fields**:

- `participants`: An ordered array of <Tooltip content={tooltipDefinitions.participant}>participant</Tooltip> addresses. Index 0 is typically the <Tooltip content={tooltipDefinitions.creatorRole}>Creator</Tooltip>, index 1 is the <Tooltip content={tooltipDefinitions.clearnode}>clearnode</Tooltip>.
- `adjudicator`: Address of the <Tooltip content={tooltipDefinitions.adjudicator}>adjudicator</Tooltip> contract responsible for validating state transitions.
- `challenge`: Challenge period duration in seconds. Determines how long a party has to respond to a challenge.
- `nonce`: A unique number that, combined with other fields, creates a unique <Tooltip content={tooltipDefinitions.channelId}>channel identifier</Tooltip>.

:::info Participant Addresses
The caller (EOA or contract) is usually different from the <Tooltip content={tooltipDefinitions.participant}>participant</Tooltip> address. Participants are derived addresses generated by the owner, similar to <Tooltip content={tooltipDefinitions.sessionKey}>session keys</Tooltip>, to enable high-frequency state signing without exposing the main wallet.
:::

## State

Represents a snapshot of <Tooltip content={tooltipDefinitions.channel}>channel</Tooltip> state at a point in time.

```solidity
struct State {
    StateIntent intent;       // Intent of the state (INITIALIZE, OPERATE, RESIZE, FINALIZE)
    uint256 version;          // State version incremental number to compare most recent
    bytes data;               // Application-specific data
    Allocation[] allocations; // Asset allocation for each participant
    bytes[] sigs;             // stateHash signatures from participants
}
```

**Fields**:

- `intent`: The intent of this state, indicating its purpose (see <Tooltip content={tooltipDefinitions.stateIntent}>StateIntent</Tooltip> enum).
- `version`: Incremental version number used to compare and validate state freshness. Higher versions supersede lower versions.
- `data`: Application-specific data. For funding states, contains magic numbers (CHANOPEN = 7877, CHANCLOSE = 7879).
- `allocations`: Array of allocations defining how funds are distributed.
- `sigs`: Array of signatures, one per <Tooltip content={tooltipDefinitions.participant}>participant</Tooltip>. Order corresponds to participants array in Channel.

## Allocation

Specifies how a particular amount of a token should be allocated.

```solidity
struct Allocation {
    address destination;  // Recipient of funds
    address token;        // ERC-20 token address
    uint256 amount;       // Token amount in smallest unit
}
```

**Fields**:

- `destination`: Address that will receive the funds when channel closes.
- `token`: Contract address of the ERC-20 token (or zero address for native currency).
- `amount`: Amount in the token's smallest unit (wei for ETH, considering decimals for ERC-20).

## Signatures

Signatures in <Tooltip content={tooltipDefinitions.nitroliteProtocol}>Nitrolite</Tooltip> are represented as variable-length byte arrays to support multiple signature schemes.

```solidity
struct Signature {
    uint8 v;      // Recovery identifier
    bytes32 r;    // First 32 bytes of signature
    bytes32 s;    // Second 32 bytes of signature
}
```

### Supported Signature Types

Since v0.3.0, the protocol supports three signature formats:

**ECDSA (EOA Signatures)**
- Standard 65-byte signatures for Externally Owned Accounts
- Used when the signer is a regular wallet address (not a contract)
- Computed over the raw <Tooltip content={tooltipDefinitions.stateHash}>stateHash</Tooltip> without EIP-191 prefix for chain-agnostic compatibility

**ERC-1271 (Smart Contract Signatures)**
- For smart contract wallets
- Verified by calling the contract's `isValidSignature()` function
- Detected when the signer address has contract code

**ERC-6492 (Counterfactual Signatures)**
- For contracts not yet deployed (counterfactual addresses)
- Contains deployment bytecode along with the signature
- Identified by the ERC-6492 detection suffix (`0x6492...6492`)
- Protocol deploys the contract if needed, then verifies via ERC-1271

The <Tooltip content={tooltipDefinitions.custodyContract}>Custody contract</Tooltip> verifies signatures in the following order:

1. Check for ERC-6492 detection suffix → verify counterfactual signature
2. Check if signer has contract code → verify ERC-1271 signature  
3. Otherwise → verify ECDSA signature from EOA

This flexible signature format enables compatibility with various wallet types while maintaining chain-agnostic principles.

:::tip Smart Wallet Support
The `bytes[]` signature format allows Nitrolite to work seamlessly with smart contract wallets, multi-signature wallets, and counterfactual contracts without requiring changes to the core protocol.
:::

## Amount

Represents a quantity of a specific token.

```solidity
struct Amount {
    address token;    // ERC-20 token address
    uint256 amount;   // Token amount
}
```

## Channel Status

Enum representing the lifecycle stage of a channel.

```solidity
enum Status {
    VOID,      // Channel does not exist
    INITIAL,   // Creation in progress, awaiting all participants
    ACTIVE,    // Fully funded and operational
    DISPUTE,   // Challenge period active
    FINAL      // Ready to be closed and deleted
}
```

**State Transitions**:

```mermaid
stateDiagram-v2
    [*] --> VOID
    VOID --> INITIAL: create()
    INITIAL --> ACTIVE: join() (all participants)
    ACTIVE --> DISPUTE: challenge()
    ACTIVE --> FINAL: close() (cooperative)
    DISPUTE --> ACTIVE: checkpoint() (newer state)
    DISPUTE --> FINAL: challenge period expires
    FINAL --> [*]
    
    note right of ACTIVE: Operational state<br/>Off-chain updates occur here
    note right of DISPUTE: Challenge period active<br/>Parties can submit newer states
```

## Protocol Constants

```solidity
constant uint256 CLIENT_IDX = 0;   // Client/Creator participant index
constant uint256 SERVER_IDX = 1;   // Server/Clearnode participant index
constant uint256 PART_NUM = 2;     // Number of participants (always 2)

constant uint16 CHANOPEN = 7877;   // 0x1EC5 - Magic number for funding state
constant uint16 CHANCLOSE = 7879;  // 0x1EC7 - Magic number for closing state
```

:::tip Magic Numbers
- **CHANOPEN (7877 / 0x1EC5)**: Signals an initial funding state during channel creation
- **CHANCLOSE (7879 / 0x1EC7)**: Signals a final closing state for cooperative closure
:::

## Identifier Computation

### Channel Identifier

The <Tooltip content={tooltipDefinitions.channelId}>channelId</Tooltip> MUST be computed as:

```javascript
channelId = keccak256(
    abi.encode(
        channel.participants,
        channel.adjudicator,
        channel.challenge,
        channel.nonce
    )
)
```

This creates a deterministic, unique identifier for each <Tooltip content={tooltipDefinitions.channel}>channel</Tooltip>. <Tooltip content={tooltipDefinitions.appChannel}>App sessions</Tooltip> use the same computation method.

:::note Deterministic IDs
Channel IDs are deterministically computed from the channel configuration, ensuring the same configuration always produces the same identifier.
:::

### State Hash

The <Tooltip content={tooltipDefinitions.stateHash}>stateHash</Tooltip> MUST be computed as:

```javascript
stateHash = keccak256(
    abi.encode(
        channelId,
        state.intent,
        state.version,
        state.data,
        state.allocations
    )
)
```

Signatures are generated over this <Tooltip content={tooltipDefinitions.stateHash}>stateHash</Tooltip>. The stateHash is signed without EIP-191 prefix as the protocol is intended to be chain-agnostic.

**Computation Process**:

```mermaid
graph LR
    A[channelId] --> D[Combine]
    B[state.data] --> D
    C[state.allocations] --> D
    D --> E[abi.encode]
    E --> F[keccak256]
    F --> G[stateHash]
    
    style G fill:#90EE90
```

:::warning Signature Verification
All state updates MUST be verified by checking signatures against the computed stateHash before accepting them on-chain.
:::

